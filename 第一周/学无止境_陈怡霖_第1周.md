# 第一天
## 如何设计秒杀服务的限流策略？
### 第一层：合法性限流
1、仅仅允许合法的请求到达服务器：过滤掉机器人和刷单用户。
2、使用验证码过滤机器人。
3、通过IP限制刷单用户。
4、隐藏秒杀入口：秒杀服务开始时再暴露秒杀地址。
### 第二层：负载限流
1、根据网络七层模型，可以在第二层进行MAC负载，在第三层进行IP负载，在第四层进行端口号负载，在第七层进行Nginx负载。
2、可以进行级联负载，但级联层数也不宜过多，因为每增加一次负载都会增加一个转发路径，进而网络延迟更大。
### 第三层：服务限流
1、设置Tomcat的最大连接数。
2、使用一些限流算法：令牌桶算法、漏桶算法。
3、使用消息队列：子系统从队列中拉取请求进行消费。
4、使用缓存限流。缓存静态请求时将html和js缓存在浏览器，将图片缓存在Nginx或转发到OSS,将视频放入CDN。缓存动态请求时搭建由本地缓存和远程缓存组成的二级缓存。

## 如何通过软引用和弱引用提升JVM内存使用效率？
### 软引用和弱引用的定义
1.如果一个对象只有软引用，则内存空间不足时就会回收该对象。
2.如果一个对象只有弱引用，则下次GC一定会回收该对象。
```Java
	String str=new String("abc");
	SoftReference<String> softRef=new SoftReference<String>(str);
	str=null;
	System.gc();
	System.out.println(softRef.get());
	String str=new String("abc");
	WeakReference<String> weakRef=new WeakReference<String>(str);
	str=null;
	System.gc();
	System.out.println(weakRef.get());
```
### 软引用的应用
在一个博客系统中，创建一个HashMap<String,SoftReference<Content>>来缓存文章，其中String表示文章ID，Content表示文章内容。用户点击文章时，根据ID到HashMap中查找，如果找到且Content不为空便直接展示；如果找不到或Contetn为空便查找数据库，找到文章后插入HashMap。值得注意的是，显示完文章后需要删除Content上的强引用。从而做到了：当内存充足时通过缓存提升性能，内存不足时会自动回收。
### 弱引用的应用
在一个电商系统中，创建一个WeakHashMap<Coupon,List<WeakReference<User>>来保存优惠劵和用户的关联。当某个User注销时，由于User对象只有弱引用，则该对象会在下次GC时回收，从而Coupon关联的用户也会自动减少，从而实现了自动更新（即用户注销时不必显式更改优惠卷和用户的对应关系）。

# 第二天
## 支付系统中，有哪些技术问题可能会引发资金损失？
### 网络异常问题
1、进行付款时支付系统会调用银行系统，假如此时网络异常，支付系统就不能达到最终状态。网络异常发生时程序会进入catch分支，此时通常会认为支付失败。然而，银行侧的状态可能是成功、失败或处理中。假如银行侧状态是成功的，商户侧却被告知支付失败，就会发起重复支付。
2、此时的正确做法是将支付系统的状态设为处理中，然后等待定时查询或通知来返回最终状态。
### 查询和通知问题
1、订单结果查询失败或查询异常并不代表这笔订单的状态是失败的，如果一概当作交易失败处理就有重复支付的风险。
2、查询频率过快也是有风险的：如果交易操作执行后立马查询交易的结果，很可能第三方系统还没来得及更改状态，导致查询反映无此订单。此时应该稍后再进行查询。

## 内部方法调用时，为什么Spring AOP增强不生效？
当在类的方法内部调用被Spring AOP标注的方法时，会发现此时增强并没有生效。这是因为Spring AOP事实上为当前类生成了一个代理对象，对该类的方法调用会转换为对代理对象方法的调用。当在类的方法内部进行调用时，并没有走代理对象。
因此，需要获取到当前类的代理对象。可以通过三种方式：
1、把自己自动注入。
2、拿到ApplicationContext，然后再调用它的getBean方法。
3、通过AopContext的currentProxy方法。此时还需在@EnableAspectJAutoProxy中设置exposeProxy=true。

# 第三天
## 为什么在做微服务设计的时候需要DDD？
1、微服务将复杂系统分而治之，即将单体应用拆分为若干微服务。然而，微服务并没有解决复杂系统如何应对需求变化这个问题：变化来临时需要花费大量精力来识别这个变化影响到了哪些微服务。
2、微服务加重了“散弹式修改”，这是因为微服务在划分复杂系统时考虑的维度并不全面：只考虑了质量维度和工程维度，忽略了质量维度。而DDD可以弥补微服务的这一缺陷。
3、复杂系统划分的首要任务是划分内部的架构边界，即划分上下文并明确它们之间的关系，这对应着功能维度，也正是DDD的用武之处。
4、架构是可以演进的。在业务发展的早期，应该更佳关注架构的逻辑边界，保持逻辑边界的清晰和关系的正确。随着业务量的增加，逐步拆分微服务。
5、在单体架构中，很难保持架构的逻辑边界不被突破。即使上下文定义得不大合适，也可以把聚合根升级为上下文，甚至拆分为微服务。

## 数据库遇到瓶颈都属于数据库问题吗？
1、对于limit语句，偏移量越大，查询所需时间就越多，因为数据库要从第一行开始一直遍历到偏移量的位置才能提取数据。此外，该语句的执行事件也和返回的数据有关。当返回的字段都在索引里时（即覆盖索引），查询速度也会很快。    然而，查询的字段通常不会全部在索引中。      
2、可以利用索引快速移动到数据的起始位置：where id>起始id，可以使用覆盖索引得到起始id，然后运用子查询得到分页查询的结果。
```sql
	select *
	from dev_info
	where id>=(
		select id
		from dev_info
		limit 4900000,1
	)
	limit 20
```
3、查询当前页的下一页数据时，只需将当前结果集底部id作为定位id，查询where id>定位id。
4、查询当前页的上一页数据时，考虑到可能存在数据删除的情况，不能将当前结果集顶部id减去结果集大小作为定位id，而是将当前结果集顶部id作为定位id，降序查询一页数据（只返回id)，再将返回的结果集底部id作为定位id。
5、在信息查询操作频率远高于信息更新操作频率的情况下，可以为信息表添加一个统计表。每次更新数据再额外更新统计表中相应的分类或标签的统计值，由于更新操作频率不高，所以给数据库造成的压力不大。在数据没有更新的情况下，可以避免进行开销很大的group by、sum等运算。
6、将链表查询改为多次单表查询。链表查询把许多环节都交给了数据库，由于数据库要保存查询的中间结果，因此开销很大：不仅增加了锁的竞争概率，而且临时表也不能有效利用索引，还会出现重复扫描的现象。

# 第四天
## Spring Data JPA如何实现动态部分更新？
1. JPA 的全程是Java Persistent API，它是一套Java持久化API规范。Spring Data JPA是对该规范的一种实现，它方便了开发者从繁杂的SQL代码中脱身出来。 
2. Spring Data JPA更新Entity时是对Entity中除主键外的所有字段进行全量更新，而不是仅仅更新传入的字段，所以未传递的字段会被覆盖为NULL。
3. 动态部分更新的概念是：并非对数据记录中的所有字段进行更新，而是直到运行时才确定更新哪些字段。
4. repository.save的逻辑是如果不存在Entity对应的记录就执行插入操作，否则执行更新操作，在更新操作之前还会执行一步查询操作。
4. 使用@Query注解可以实现部分更新；使用@DynamicUpdate注解可以实现动态部分更新，但无法处理遇到NULL值后想忽略的情况。
## Spring Data JPA如何进行复杂动态查询？
1.复杂查询是指非单表查询，或者是join操作，或者是子查询。动态查询是指在运行时才确定具体的查询条件。
2.Spring Data JPA更加适合OLTP场景，尤其是单表的CRUD操作，它大大减少了程序员在数据访问层的代码开发量。数据分析型的OLAP场景更加适合Mybatis。
3.使用@Query注解可以实现复杂查询，但不大灵活；@OneToMany、@ManyToOne、@ManyToMany等注解使用成本太高，且涉及数据表的外键和级联操作，因此对性能有影响。
4.Querydsl是解决该问题的优雅方案。