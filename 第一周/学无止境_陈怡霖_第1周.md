# 第一天
## 如何设计秒杀服务的限流策略？
### 第一层：合法性限流
1. 仅仅允许合法的请求到达服务器：过滤掉机器人和刷单用户。
2. 使用验证码过滤机器人。
3. 通过IP限制刷单用户。
4. 隐藏秒杀入口：秒杀服务开始时再暴露秒杀地址。
### 第二层：负载限流
1. 根据网络七层模型，可以在第二层进行MAC负载，在第三层进行IP负载，在第四层进行端口号负载，在第七层进行Nginx负载。
2. 可以进行级联负载，但级联层数也不宜过多，因为每增加一次负载都会增加一个转发路径，进而网络延迟更大。
### 第三层：服务限流
1. 设置Tomcat的最大连接数。
2. 使用一些限流算法：令牌桶算法、漏桶算法。
3. 使用消息队列：子系统从队列中拉取请求进行消费。
4. 使用缓存限流。缓存静态请求时将html和js缓存在浏览器，将图片缓存在Nginx或转发到OSS,将视频放入CDN。缓存动态请求时搭建由本地缓存和远程缓存组成的二级缓存。

## 如何通过软引用和弱引用提升JVM内存使用效率？
### 软引用和弱引用的定义
1. 如果一个对象只有软引用，则内存空间不足时就会回收该对象。
2. 如果一个对象只有弱引用，则下次GC一定会回收该对象。
```Java
	String str=new String("abc");
	SoftReference<String> softRef=new SoftReference<String>(str);
	str=null;
	System.gc();
	System.out.println(softRef.get());
	String str=new String("abc");
	WeakReference<String> weakRef=new WeakReference<String>(str);
	str=null;
	System.gc();
	System.out.println(weakRef.get());
```
### 软引用的应用
在一个博客系统中，创建一个HashMap<String,SoftReference<Content>>来缓存文章，其中String表示文章ID，Content表示文章内容。用户点击文章时，根据ID到HashMap中查找，如果找到且Content不为空便直接展示；如果找不到或Contetn为空便查找数据库，找到文章后插入HashMap。值得注意的是，显示完文章后需要删除Content上的强引用。从而做到了：当内存充足时通过缓存提升性能，内存不足时会自动回收。

### 弱引用的应用
在一个电商系统中，创建一个WeakHashMap<Coupon,List<WeakReference<User>>来保存优惠劵和用户的关联。当某个User注销时，由于User对象只有弱引用，则该对象会在下次GC时回收，从而Coupon关联的用户也会自动减少，从而实现了自动更新（即用户注销时不必显式更改优惠卷和用户的对应关系）。

# 第二天
## 支付系统中，有哪些技术问题可能会引发资金损失？
### 网络异常问题
1. 进行付款时支付系统会调用银行系统，假如此时网络异常，支付系统就不能达到最终状态。网络异常发生时程序会进入catch分支，此时通常会认为支付失败。然而，银行侧的状态可能是成功、失败或处理中。假如银行侧状态是成功的，商户侧却被告知支付失败，就会发起重复支付。
2. 此时的正确做法是将支付系统的状态设为处理中，然后等待定时查询或通知来返回最终状态。
### 查询和通知问题
1. 订单结果查询失败或查询异常并不代表这笔订单的状态是失败的，如果一概当作交易失败处理就有重复支付的风险。
2. 查询频率过快也是有风险的：如果交易操作执行后立马查询交易的结果，很可能第三方系统还没来得及更改状态，导致查询反映无此订单。此时应该稍后再进行查询。

## 内部方法调用时，为什么Spring AOP增强不生效？
当在类的方法内部调用被Spring AOP标注的方法时，会发现此时增强并没有生效。这是因为Spring AOP事实上为当前类生成了一个代理对象，对该类的方法调用会转换为对代理对象方法的调用。当在类的方法内部进行调用时，并没有走代理对象。
因此，需要获取到当前类的代理对象。可以通过三种方式：
1. 把自己自动注入。
2. 拿到ApplicationContext，然后再调用它的getBean方法。
3. 通过AopContext的currentProxy方法。此时还需在@EnableAspectJAutoProxy中设置exposeProxy=true。

# 第三天
## 为什么在做微服务设计的时候需要DDD？
1. 微服务将复杂系统分而治之，即将单体应用拆分为若干微服务。然而，微服务并没有解决复杂系统如何应对需求变化这个问题：变化来临时需要花费大量精力来识别这个变化影响到了哪些微服务。
2. 微服务加重了“散弹式修改”，这是因为微服务在划分复杂系统时考虑的维度并不
